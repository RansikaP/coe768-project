# coe768-project
## Introduction
  This project is a P2P (Peer-to-Peer) application that consists of the main index server and several peer servers. This application allows the peers to exchange content amongst each other with the assistance of the index server which acts as a middleman to prepare the peers and their content to be shared among each other. A peer could have a piece of data such as a text file or song available for download for other peers, respectively called the content server and content client respectively. The index server is the one that organizes all these peers’ content and acts like a table of content for the other peers to know where the desired content is located. A peer can also be a content server of more than one piece of content, as well as being a content client to another peer. The communication between the index server and a peer is based on UDP, while a peer-to-peer content download is on TCP for more reliability. When a socket is created it is bound to an address and port number. Then the server will wait for the peers to attempt a connection. If the connection is successful a socket connection will be created between the peer and server, or peer to peer. As mentioned above, for peer-to-peer content download TCP sockets are used and for peer, to server communication, UDP sockets are used. 

## Description of the client and server programs
### Protocol Implementation
Client Program (Peer)

  The client program is a peer that allows the user to enter a username and then have the ability to exchange their content on their device with other peers who share the same index server. The client-server uses both UDP and TCP sockets, mainly UDP with the index server and TCP for content download with the other peers. There are 8 PDU types/protocols that the peer program uses. R (Content Registration), D (Content Download Request), S (Search for content and the associated content server), T (Content De-Registration), C (Content Data), O (List of On-Line Registered Content), A (Acknowledgement), and lastly E (Error). 

  To begin with, if the client wants to register a piece of content it would need to communicate with the index server, through a UDP connection. Once a UDP connection is established between the index server and content server (peer) the user would input the command “R” to declare a request to register content to the index server. The user will then input the name of the content that they want to register to the index server, by registering this content to the index server, other peers connected to the index server will be able to see that this content is available at this specific content server. The R-type PDU will take in the peer’s name, content name, and the address of the content server. If the whole process is successful, the index server will send an A-type PDU back to the peer to acknowledge that the content has been registered. However, if it is unsuccessful the index server will send an E-type PDU back to notify of an error. One possible error is that the peer’s username is already taken, so the peer is asked to change their username. 

  If a peer wants to see the list of all the registered content, it will need to establish a UDP connection with the index server and then send an O-type PDU, by entering “O” as a command input. The index server will go through all the registered content from all the peers and then display it on the terminal. If the process was successful the index server will return an O-type PDU back to the peer. If there is nothing registered yet, the program will display nothing. 

  If a peer wants to deregister a specific piece of content, it will once again create a UDP connection with the index server and then send the name of the content that the peer wants to deregister. To begin, the user will input a “T” command, to indicate it wants to send a T-type PDU to the index server, along with the name of the content to be registered. If the process is successful the index server will return back an A-type PDU to the peer to indicate that the content has been successfully deregistered. The content should no longer be viewable with the O-type PDU command.

  When a peer wants to download a certain piece of content, it first needs to create a UDP connection with the index server. Then the user will enter a “D” command into the terminal along with the name of the file that it wishes to download. The “D” command from the peer will send an S-type PDU to the index server. The S-type PDU contains the username of the client and the desired content. With this information, the index server will look if it contains a file that matches the name of the desired content. If it does, it will return an S-type PDU back to the peer and it will also contain the address of the peer that’s acting as a content server for that specific content. If the content is not found or another error occurs the index server will return an E-type PDU back to the peer indicating an error. Once the peer successfully receives the S-type PDU from the index server it will establish a TCP connection to the content server specified in S-type PDU data that contains the content server’s address. The peer server will then send a D-type PDU to the content server, which will contain the name of the content that’s being requested. Once the content server receives the D-type PDU successfully and the file is found, it will return a C-type PDU back to the client-server. The C-type PDU contains the requested content. Once the client-server receives and downloads the content it will become a content server for that content as well. 

  Lastly, if a peer decides to leave the server, the peer will create a UDP connection with the index server to communicate. Then the user will enter the “Q” command to quit/disconnect from the network. When the client decides to quit, all of the registered content connected to that client will have to be deregistered, so the client will send a T-type PDU to the index server to de-register all this existing content corresponding to itself. If there is more than 1 piece of content that needs to be deleted, the client will have to send multiple T-type PDUs to the index server, as each T-type PDU only specifies 1 piece of content to be deregistered at a time.

Server Program (Server)

  The index server acts as a middleman for the peers, it keeps account of what peer contains what content and their respective addresses. The main responsibility of the index server is registering content, deregistering content, and showing all the available content between all the peers. The server mainly communicates with the peer servers through UDP connections, while TCP connections are mainly reserved for peer-to-peer content exchange. 

  If the index server receives an R-type PDU from a peer, it knows that it’s a request to register content. The server will first check if the peer’s username is unique, if not it will send back an E-type PDU to correspond to an error and ask the peer to change their username. If the peer’s username is unique the index server will take the R-type PDU and register that content. If successful it will send an A-type PDU back to the peer server acknowledging that the content registration is complete. 

  If the index server receives an O-type PDU, the server knows that this request is for a list of on-line registered content. The index server will send the client an O-type PDU back to the peer. The connection between the peer and server is UDP. 

  If the index server receives a T-type PDU, the server knows that the peer is requesting to deregister a piece of content. The index server will look for that content, and then deregister it. If the deregistration is successful it will send the client an A-type PDU to acknowledge that the content has been deregistered. The connection between the peer and server is UDP. 

  If the index server receives an S-type PDU, the client is looking to download content. The connection between the peer and server is UDP. The server checks the S-type PDU for a valid username and makes sure that the content name that’s requested is registered. If both are valid then the index server will send an S-type PDU back to the client containing the address of the content server to download the content. If it’s invalid, the index server will send an E-type PDU back to the client indicating that there’s an error. Once the client successfully receives the S-type PDU back with the address of the peer that’s the content server of the desired content, the client-server will create a TCP connection with that content server. Then the client-server will send a D-type PDU to the content server, the PDU contains the name of the desired content. The content server will return a C-type PDU back to the client, containing the contents of the file. If the file is too large, the content server will send multiple TCP packets back to the client-server each containing portions of the content. Once all the data has been sent, the content server will end the TCP connection. The client will now become a content server of the recently downloaded content. When multiple peers are content servers of the same content, the index server will redirect clients looking for that content to the address of the content server with the least amount of use. 

## Detailed Description of Program
Starting from figure 7 begins the implementation of the peer program, where all required imports, variables, and functions are declared. In figure 8, the address of the server is declared, sockets are created and the initial port and address for listening on the peer are bound to the socket. In figures 9 and 10, the program determines whether it is acting as a client or server, and redirected the data to the correct function. If the data is from the user it is sent to ‘userInit’ function, where it enters a switch statement to determine which command the user issued. For a ‘?’ command the function ‘printoption’ is called which prints all available commands. For a ‘Q’ command the program is quit. For a ‘D’ command the program asks the user what content should be downloaded, and calls the ‘server_connection1’ function, to check whether the data exists with the index server and return a TCP socket to communicate with the relevant peer. If the data exists a TCP connection is opened with the specified peer and the incoming data is written to a file. For an ‘R’ command the program asks the user what content they want to register and then creates a PDU of type R to be sent to the index server using the ‘initPDU’ function. Once the PDU is created it is written to the server and depending on the received response from the server the number of registered content for the peer is incremented. In figure 11, for a command ‘T’ the program asks the user what content they want to deregister, creates a PDU of type ‘T’ and writes that to the index server. For the ‘O’ command a PDU of type ‘O’ is created and written to the index server, the response is then outputted to the user. Next is the clientInit function which defines hows the peer should act as a content server, shown in figures 11 and 12.  For a received ‘rpdu’ type ‘D’ the program attempts to open the file specified by the content name and send the data using 100-byte PDUs of type ‘C’ and type ‘F’ for the final PDU, if there is any error in sending the file a PDU of type ‘E’ is sent. In figures 12 and 13, you can see the serverconnection_1 function which is used for the content download command. It first checks with the index server if and where the content exists using UDP then returns a TCP socket to the specified peer where the requested content is stored. Finally, in figure 13, we can see the ‘printoption’ function which displays all the functions available to the user when the ‘?’ command is used. We can also the ‘initPDU’ function which is used to initialize PDUs to a specific type, content, and username.

Starting from figure 14 begins the implementation of the server program, where all required imports, variables, and functions are declared. In figure 15 we define the server address and ports, create a socket, bind the socket to the server address and port, and being listening on it. We use a while loop to handle incoming requests. If the request is of type ‘R’ first the content array is checked to see if there is a matching combination of peer and content name, if it already exists an ‘E’ PDU is returned to the client. If the content does not exist already on the server it is stored in the contents array, and the number of contents and peers stored in the server is incremented.  In figure 16, if the request type is ‘O’ first the program checks if any content is registered in the server, if not a PDU type ‘E’ is sent to the peer. If there is content registered on the server the ‘obtain_list’ function is called which stores the list of content in the ‘message’ variable, which is then sent as PDU data to the peer using a UDP connection. For the case of a ‘T’ request, the program first locates the array index where the specified content is stored. The data at that array location is then removed and the rest of the array is shifted down to fill in the gap. Once this is completed the server sends an ‘A’ type response PDU to the peer. In figure 17, for the request type ‘S’, the server program first finds the location of the requested content in the ‘contents’ array. If the specified content is not registered, the ‘pc_index’ variable is set o -1 and a PDU of type ‘E’ is sent to the peer. If the specified content is found, the array index it is found in is stored in ‘pc_index’ and using the index the address of the requested content is sent to the peer with PDU type ‘S’. Finally, the obtain lists buffer iterates through the ‘contents’ array, formats the contents, and stores the output in the ‘message’ variable address to be sent to the user for a request type ‘O’.

## Observations and Analysis 
![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig1.png)
*Figure 1: Initial screen for peers*
When the user first boots up the peer program, a user name is required for the peer.

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig2.png)
*Figure 2: Setup of the username and using O and ? commands*

After setting up the username for the peer, the user may use any of the commands specified by the ‘?’ command which displayed all available commands to the user. Using the ‘O’ command the user can view what content is currently registered on the index server.

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig3.png)
*Figure 3a: Registering content on the peer side*

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig4.png)
*Figure 3b: Registering content on the server side*

Using the ‘R’ command the user can register on the index server any content the peer may have. The index server saves the peer name, content name, and address of the registering peer.

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig5.png)
*Figure 4: Using the O command to show the list of content from the index server the on peer*

Now when the user uses the ‘O’ command from the peer the registered content is shown.

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig6.png)
*Figure 5a: Downloading content on a 2nd peer*

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fgi7.png)
*Figure 5b: Content download seen from index server*

Using the ‘D’ command a user may download content from one peer to another. Here the peer ‘user2’ downloads the ‘movie.txt’ content that was registered by ‘user1’ earlier. When this download successfully occurs the index server updates the new peer name and address of the peer to the location where the content was downloaded to.

![](https://github.com/RansikaP/coe768-project/blob/main/assets/fig7.png)
*Figure 6: Deregistering content as seen from peer and server*

Using the T command the user may register any content they have registered to or downloaded from the index server. Unfortunately for our project this command contains some errors and does not correctly remove the specified content from the index server.

## Conclusion
  In conclusion our peer-to-peer application was able to have communication between the index server and multiple peers, being able to have peer-to-peer and peer-to-server connections. The peers were able to successfully register content to the server, download content from another peer, view a list of all registered content from the server, and quit the application. Unfortunately, while our deregistering command was able to display the correct content to deregister in practice it was unable to complete this task. All connection to the index server was based on UDP, as the data being sent was not very important and communication time was more important. All connections between peers were done using TCP, as the data being sent was the content and ensuring successful delivery is more important than speed. Therefore, our application met all the specified requirements and functions it should, other than content registration.
